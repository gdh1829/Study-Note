# Spring AOP

## 배경
- Application의 기능은 크게 핵심 기능과 부가 기능으로 나뉨.
- 그런데, 부가 기능이 여러 곳에서 공통으로 사용하는 경우가 있음. 
    - `cross-cutting concerns` 횡단 관심사라고 함.
- 이러한 횡단 관심사의 부가기능은 코드의 중복과 반복, 수백의 적용 대상 수정 발생시 큰 코드읩 변경이 발생. 이 경우 일반적인 OOP 방식의 해결이 어려움.
- 그래서 애플리케이션을 바라보는 관점을 하나 하나의 기능에서 횡단 관심사 관점으로 달리 보는 것으로 Aspect를 사용한 프로그래밍을 `관점 지향 프로그래밍`이라 함.

## AspectJ AOP 적용방식
크게 3가지가 있음.
- 컴파일 시점
- 클래스 로딩 시점
- 런타임 시점(프록시)

### 컴파일 타임 위빙
`.java` 소스코드를 컴파일러를 사용해 `.class`를 만드는 시점에 부가 기능 로직을 추가.
부가 기능 코드를 핵심 기능이 있는 컴파일된 코드 주변에 실제로 붙여 버리는 것.
AspectJ 컴파일러는 Aspect를 확인하여 해당 클래스가 적용대상인지 먼저 확인하고, 적용 대상인 경우에 부가 기능 로직을 적용.
원본 로직에 부가 기능 로직이 추가되는 것을 위빙이라고 함.
컴파일 시점에 부가 기능을 적용하려면 특별한 컴파일러도 필요하고 복잡한 단점이 있음.

### 클래스 로드 타임 위빙
자바를 실행하면 자바 언어는 .class 파일을 JVM 내부의 클래스 로더에 보관. 이때 중간에 `.class` 파일을 조작한 다음 JVM에 올릴 수 있음. .class를 JVM에 저장하기 전에 조작할 수 있는 기능을 제공.(`java instrumentation`). 참고로 수많은 모니터링 툴 들이 이 방식을 사용. 이 시점에 애스팩트를 쓰는 것을 로드 타임 위빙이라 함.
로드 타임 위빙은 자바를 실행할 때 특별한 옵션(`java -javaagent`)을 통해 클래스 로더 조작기를 지정해야하는데, 이 부분이 번거롭고 운영하기 어려움.

### 런타임 위빙
컴파일, 클래스 로드 타임이 모두 지나고 자바가 이미 실행된 다음을 의미하는데, 따라서 자바 언어가 제공하는 범위 안에서 부가 기능을 적용해야함. 
스프링과 같은 컨테이너의 도움을 받고, 프록시와 DI, Bean PostProcessor 같은 개념을 총동원하여 최종적으로 Proxy를 통해 스프링 빈에 부가기능을 적용 가능. 이것이 프록시 방식의 AOP.

## AOP의 적용위치
- 적용 가능 지점(조인 포인트): 생성자, 필드 값 접근, static 메서드 접근, 실행
    - AOP를 적용할 수 있는 지점을 `Join point`라 함.
- AspectJ를 사용해서 컴파일/클래스 로딩 시점에 적용하는 AOP는 바이트코드를 실제로 조작하기 때문에 모든 지점에 적용 가능.
- 프록시 방식을 사용하는 스프링 AOP는 메서드 실행 지점에만 AOP적용 가능.
    - 프록시는 메서드 오버라이딩 개념으로 동작. 따라서 생성자나 static 메서드, 필드 값 접근에는 프록시 개념 적용 X
    - 프록시를 사용하는 **스프링 AOP의 조인 포인트는 메서드 실행으로 제한**됨.
    - 스프링 AOP는 스프링 컨테이너가 관리할 수 있는 **스프링 빈에만 AOP를 적용** 가능
    - 스프링은 AspectJ의 문법을 차용하고 프록시 방식의 AOP를 적용하는 것이지 직접 AspectJ를 사용하는 것이 아님.

## @AOP 프록시
- AnnotationAwareAspectJAutoProxyCreator: 자동프록시 생성기 
    - Advisor를 자동으로 찾아와서 필요한 곳에 프록시를 생성하고 적용해준다.
    - Aspect를 찾아서 Advisor로 만들어준다. @Aspect를 Advisor로 변환해서 저장하는 기능. 때문에 AnnotationAware라는 이름이 붙은 것.


1. @Aspect를 Advisor로 변환 및 저장하는 과정
    1. 스프링 애플리케이션 로딩 시점에 자동 프록시 생성기를 호출.
    1. 자동 프록시 생성기는 스프링 컨테이너에서 모든 @Aspect 빈 조회.
    1. @Aspect 어드바이저 빌더를 통해 @Aspect 어노테이션 정보를 기반으로 어드바이저를 생성.
        - @Aspect 어드바이저 빌더
            - BeanFactoryAspectJAdvisorBuilder 클래스이다. @Aspect의 정보를 기반으로 포인트컷, 어드바이스, 어드바이저를 생성/보관 담당. @Aspect의 정보를 기반으로 어드바이저를 만들고, @Aspect 어드바이저 빌더 내부 저장소에 캐시. 캐시에 어드바이저가 이미 만들어져 있는 경우 캐시에 저장된 어드바이저를 반환.
    1. 생성한 어드바이저를 @Aspect 어드바이저 빌더 내부에 저장 관리

1. 어드바이저를 기반으로 프록시 생성
    1. 스프링 빈 대상이 되는 객체 생성
    1. 생성된 객체를 빈 저장소에 등록하기 직전에 자동프록시생성기-빈 후처리기에 전달
    1. 어드바이저 빈 조회.
        1. 스프링 컨테이너에서 Advisor 빈을 모두 조회.
        1. Plus, @Aspect 어드바이저 빌더 내부에 저장된 Advisor도 모두 조회.
    1. 3-1, 3-2에서 조회한 Advisor에 포함되어 있는 포인트컷을 사용해서 해당 객체가 프록시를 적용할 대상인지 아닌지 판단. 이때 객체의 클래스 정보는 물론이고, 해당 객체의 모든 메서드를 포인트컷 하나하나 모두 매칭해본다. 그래서 조건이 하나라도 만족하면 프록시 적용 대상이 된다. 메서드 하나만 포인터컷 조건에 만족해도 프록시 적용 대상이 됨. 
    1. 프록시 적용 대상이 되면 프록시를 생성하고 프록시 반환. 프록시를 스프링 빈으로 등록. 프록시 적용 대상이 아니라면 원본 객체를 반환해서 원본 객체를 스프링 빈으로 등록.


## AOP 용어
- Join Point
    - 추상적인 개념으로 AOP가 적용될 수 있는 모든 지점.
    - __스프링 AOP는 프록시 방식을 사용하므로 조인 포인트는 항상 메소드 실행 시점으로 제한__.
- Pointcut
    - 조인 포인트 중에서 어드바이스가 적용될 위치를 선별하는 기능.
    - 프록시를 사용하는 스프링 AOP는 메서드 실행 지점만 포인트컷으로 선별 가능.
- Target
    - 어드바이스를 받는 객체, 포인트컷으로 결정.
    - 스프링 AOP에서는 프록시가 호출하는 실제 부가 기능 객체.
- Advice
    - 부가 기능
    - Around, Before, After 등과 같은 다양한 종류의 어드바이스가 있음.
- Aspect
    - Advice + Pointcut을 모듈화 한 것.
    - @Aspect
    - 여러 어드바이스와 포인트 컷이 함꼐 존재.
- Advisor
    - 하나의 Advice + 하나의 Pointcut으로 구성.
    - 스프링 AOP에서만 사용되는 특별한 용어.
- Weaving
    - 포인트컷으로 결정한 타겟의 조인 포인트에 어드바이스를 적용하는 것.
    - 위빙을 통해 핵심 기능 코드에 영향을 주지 않고 부가 기능을 추가할 수 있음.
    - AOP 적용을 위해 Aspect를 객체에 연결한 상태
        - 컴파일 타임 위빙(AspectJ compiler)
        - JVM class 로드 타임 위빙
        - 런타임 위빙: 스프링 AOP가 프록시를 사용하여 제공하는 방식.
- AOP Proxy
    - AOP 기능을 구현하기 위해 만든 프록시 객체. 
    - 스프링 AOP의 프록시는 `JDK 동적 프록시` 또는 `CGLIB 프록시`임.
