# 프록시 패턴과 데코레이터 패턴

## 프록시(Proxy)의 주요 기능
- 접근제어
    - 권한에 따른 접근 차단
    - 캐싱
    - 지연 로딩
- 부가 기능 추가
    - 본래 서버가 제공하는 기능에 더해서 부가 기능 수행
        - ex. 요청 값이나, 응답 값을 중간에 변형
        - ex. 실행시간 측정 추가 로깅  
- Chaining

GoF 디자인 패턴에서는 의도(intent)에 따라 Proxy Pattern과 Decorator Pattern으로 구분
- Proxy 패턴: 다른 개체에 대한 **접근 제어**하기 위해 대리자를 제공.
- Decorator 패턴: **객체에 추가 책임(기능)을 동적으로 추가**하고, 기능 확장을 위한 유연한 대안 제공.
둘다 Proxy를 사용하지만, 의도가 다른 것이 핵심. 
두 패턴 모두 Proxy를 사용하나 목적이 접근 제어라면 프록시 패턴, 기능 추가 목적이라면 데코레이터 패턴이라 할 수 있다.

![Decorator_Pattern_UML](./images/W3sDesign_Decorator_Design_Pattern_UML.jpg)

인터페이스 기반 프록시와 클래스 기반 프록시

클래스 기반 프록시는 상속 사용으로 인한 제약이 따라옴.
인터페이스 기반 프록시는 캐스팅 관련하여 단점이 있음.

이론적으로는 모든 객체에 인터페이스를 도입하여 역할과 구현을 나누는 것이 좋다. 이러면 역할과 구현을 나누어서 구현체를 편리하게 변경가능. 하지만 실제로는 구현을 거의 변경할 일이 없는 클래스들도 많음.
인터페이스를 도입하는 것은 구현을 변경할 가능성이 있을 때 효과적인데, 구현을 변경할 가능성이 거의 없는 코드에 무작정 인터페이스를 사용하는 것은 번거롭고 그렇게 실용적이지도 않음. 이런곳에서는 실용적 관점에서 인터페이스를 사용하지 않고, 구체 클래스를 바로 사용하는 것이 좋을 수 있음. 물론 인터페이스를 도입하는 다양한 이유가 있으나 여기서의 핵심은 인터페이스가 항상 필요한 것은 아니다라는 것.

개방폐쇄의 원칙: OCP(Open Close Principal) 
객체지향설계 5대 원칙 
"소프트웨어의 구성 요소(컴포넌트, 클래스, 모듈, 함수)는 확장에 대해서는 개방(Open)되어야 하지만 변경에 대해서는 폐쇄(Close)되어야 한다."
즉, 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.

방법
1. 상속(is-a)
1. 컴포지션(has-a)

적용 3단계
1. 변경(확장)될 것과 변하지 않을 것을 엄격히 구분
1. 이 두 모듈이 만나는 지점에 인터페이스를 정의
1. 구현에 의존하기 보다는 정의한 인터페이스에 의존하도록 코드 작성
